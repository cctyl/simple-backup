	
	
android 发送md5和文件路径（因为可能存在相同文件在不同路径）
	后端检查是否存在，
	找到不存在的文件信息，返回md5和文件路径
	
	
android找到变化的文件
	上传md5，文件名，文件大小，文件路径
	
	
	
android存储什么？

	上次备份时间

	已选择的要备份的目录列表
	
	已扫描过的文件的md5和路径信息
	
	修改时间小于上次备份时间，且已被扫描过的，无需再次备份
	
	
	
后端接口

	
	POST /api/compare
	[
		{
			String name;       
			Uri treeUri;      
			String docId;      
			String md5;  
			String releactivePath;
			boolean isDirectory
		}
	]
	
	
	
	POST /api/upload
	表单
		String name;       
		Uri treeUri;      
		String docId;      
		String md5;  
		String releactivePath;
		boolean isDirectory
		
		
		file = 二进制
		
		
		
我要做一个增量备份文件的软件，下面是我的思路，还有哪些地方能够优化？
帮我梳理一下功能：
	app遍历本地文件
	然后问服务端
	有没有这些文件
	服务端把没有的列表返回
	app上传这些文件		

app
	记录文件hash，通过hash来对比文件是否发生修改
	
	app本地数据库记录已备份过的文件（hash和文件路径对比）
	
	
	文件路径如何获得？如何提交给服务端？
		
		都是相对路径，选择的文件夹都会作为根目录进行存储
		
	
	app应该告知总共多少文件需要备份
	
	app要弹出一个通知栏，然后可以在后台进行服务，而不需要常驻在界面，不应该影响手机的使用
	
	
	每一次上传文件，都检查一次是否需要暂停，从而可以实现随时停止
		
		
服务端
	同路径的文件，如果再次上传，进行覆盖操作
	
	
	上传时，应该保存为临时文件，上传完毕后再删除旧文件，移动新文件
		这样如果客户端上传失败，旧的文件也可以保留
		
		




android文件读取实现

	我正在做一个数据备份的app，现在这个界面就是选择需要备份的文件夹的界面。现在界面我已经写好（html+webview）,你不需要考虑界面的实现。
	 我的问题是：
		1.我能否在安卓中拿到这样树形的文件夹列表？
		2.如果能拿到，拿到的是路径吗？如果拿不到怎么办？那我的页面怎么显示
		3.前端选择文件夹后，该把什么提交给安卓？文件夹路径吗？
		
		
		我的目标是android10及以上，你应该给出android10以上的实现
		
		
	
	似乎用saf，然后让用户手动选择会更好


android 10 和以下的实现

	if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
                != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, 1);
	}


	package com.example.myapplication.utils;

	import android.os.Environment;
	import android.util.Log;

	import java.io.File;

	public class FolderTraversal {

		private static final String TAG = "FolderTraversal";

		/**
		 * 遍历指定目录及其子目录中的所有文件夹，并将路径输出到 Logcat。
		 *
		 * @param rootDirectory 要遍历的根目录
		 * @param depth         当前递归深度（用于防止无限递归或限制层级）
		 */
		public static void listDirectories(File rootDirectory, int depth) {
			if (rootDirectory == null || !rootDirectory.exists() || !rootDirectory.isDirectory()) {
				Log.w(TAG, "无效的目录: " + rootDirectory);
				return;
			}

			if (depth > 10) {
				Log.d(TAG, "递归深度限制，停止遍历");
				return;
			}

			// 输出当前目录路径
			Log.d(TAG, "目录: " + rootDirectory.getAbsolutePath());

			File[] files = rootDirectory.listFiles();
			if (files != null) {
				for (File file : files) {
					if (file.isDirectory()) {
						// 递归处理子目录
						listDirectories(file, depth + 1);
					}
				}
			}
		}

		// 示例调用
		public static void startTraversal() {
			
			Log.d("---->  FolderTraversal","开始读取文件夹"     );
			File root = Environment.getExternalStorageDirectory(); // 根目录（如 /storage/emulated/0）
			Log.d("---->  FolderTraversal","根目录是："+root.getAbsolutePath()     );
			listDirectories(root, 0);
		}
	}		
		
	
	
	
	
	
界面点击发起备份
	
	
	逐层遍历文件夹，
		每20个则查询一次数据库，留下 relativePath一致，但是 md5不一致的的文件。
		
	得到了全部需要上传的文件
		
		通知界面总数
		
	开始备份
		
		计算一个备份进度
			按已上传数量和总数做百分比
		
		发起一个后台服务，
			附带一个通知
				通知上有总体备份进度条
		
		okhttp对文件进行上传
			表单格式
			
		计算本文件的上传速度
		
		
		每秒更新一次数据，通知js